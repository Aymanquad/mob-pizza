const Order = require('../models/Order');
const User = require('../models/User');
const MenuItem = require('../models/MenuItem');

/**
 * Create new order
 */
exports.createOrder = async (req, res) => {
  try {
    // Express automatically URL decodes params, but let's be explicit
    let { phone } = req.params; // Can be phone, email, or googleId
    phone = decodeURIComponent(phone);
    const orderData = req.body;

    console.log('[order] Creating order for identifier:', phone);
    console.log('[order] Order data:', JSON.stringify({
      itemsCount: orderData.items?.length || 0,
      customerName: orderData.customerName,
      phoneNumber: orderData.phoneNumber,
      totalPrice: orderData.totalPrice,
    }));

    // Find user by phone, email, or googleId
    let user = null;
    let query = {};
    
    // Check if identifier is an email
    if (phone.includes('@')) {
      query = { email: phone.toLowerCase() };
      console.log('[order] Looking up user by email:', phone.toLowerCase());
      user = await User.findOne(query);
    }
    
    // If not found and not an email, try phone
    if (!user && !phone.includes('@')) {
      query = { phone };
      console.log('[order] Looking up user by phone:', phone);
      user = await User.findOne(query);
    }
    
    // If still not found, try googleId (for long numeric strings)
    if (!user && phone.length > 15 && /^\d+$/.test(phone)) {
      query = { googleId: phone };
      console.log('[order] Looking up user by googleId:', phone);
      user = await User.findOne(query);
    }
    
    if (!user) {
      console.error('[order] User not found for identifier:', phone);
      return res.status(404).json({
        success: false,
        message: 'User not found',
      });
    }
    
    console.log('[order] Found user:', user._id, 'role:', user.role);

    // Validate required fields
    if (!orderData.items || !Array.isArray(orderData.items) || orderData.items.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Order must contain at least one item',
      });
    }

    // Map mobile size names to backend enum values
    const mapSizeToEnum = (size) => {
      const sizeLower = (size || '').toLowerCase();
      switch (sizeLower) {
        case 'solo':
          return 'small';
        case 'crew':
          return 'medium';
        case 'family':
          return 'large';
        default:
          return 'medium'; // Default fallback
      }
    };

    // Build order items with menu item references
    const orderItems = [];
    for (const item of orderData.items) {
      // Try to find menu item by ID if provided
      let menuItem = null;
      if (item.menuItemId) {
        menuItem = await MenuItem.findById(item.menuItemId);
      }

      // Map size from mobile format to backend enum
      const mappedSize = mapSizeToEnum(item.selectedSize);
      console.log(`[order] Mapping size: "${item.selectedSize}" -> "${mappedSize}"`);

      // Build order item - only include menuItem if we have it
      const orderItem = {
        name: item.name || 'Unknown Item',
        image: item.imagePath || (menuItem ? menuItem.image : null),
        size: mappedSize,
        quantity: item.quantity || 1,
        addOns: (item.selectedToppings || []).map((topping) => ({
          name: topping,
          price: 0, // You may want to calculate this from menu item
        })),
        description: item.description || '',
        specialInstructions: item.specialInstructions || '',
        pricePerUnit: item.basePrice || 0,
        total: (item.basePrice || 0) * (item.quantity || 1),
      };

      // Only add menuItem if we have a reference
      if (menuItem && menuItem._id) {
        orderItem.menuItem = menuItem._id;
      }

      orderItems.push(orderItem);
    }

    // Calculate totals
    const subtotal = orderItems.reduce((sum, item) => sum + item.total, 0);
    const deliveryCharges = orderData.deliveryCharges || 0;
    const tax = orderData.tax || subtotal * 0.1; // 10% tax default
    const discount = orderData.discount || 0;
    const totalAmount = subtotal + deliveryCharges + tax - discount;

    // Create order (orderId will be auto-generated by pre-save hook)
    console.log('[order] Creating order with items:', JSON.stringify(orderItems.map(i => ({ name: i.name, size: i.size, hasMenuItem: !!i.menuItem })), null, 2));
    const order = new Order({
      customer: user._id,
      items: orderItems,
      orderType: orderData.orderType || 'delivery',
      deliveryAddress: orderData.deliveryAddressId || null,
      pickupLocation: orderData.pickupLocation || null,
      subtotal,
      deliveryCharges,
      tax,
      discount,
      promoCode: orderData.promoCode || null,
      totalAmount,
      paymentMethod: orderData.paymentMethod || 'cash',
      paymentStatus: 'pending',
      orderStatus: 'pending',
      customerNotes: orderData.customerNotes || '',
      estimatedDeliveryTime: orderData.estimatedDelivery
        ? new Date(orderData.estimatedDelivery)
        : new Date(Date.now() + 30 * 60 * 1000), // 30 mins default
    });

    console.log('[order] About to save order, orderId will be auto-generated');
    await order.save();
    console.log('[order] Order saved successfully with orderId:', order.orderId);

    // Update user's order count
    user.ordersCount = (user.ordersCount || 0) + 1;
    user.lastOrderAt = new Date();
    await user.save();

    // Populate order for response
    await order.populate('customer', 'firstName lastName phone');
    await order.populate('items.menuItem', 'name image');

    return res.status(201).json({
      success: true,
      message: 'Order created successfully',
      data: order,
    });
  } catch (error) {
    console.error('[order] error creating order:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to create order',
      error: error.message,
    });
  }
};

/**
 * Get user's orders (or all orders if user is admin/host)
 */
exports.getOrders = async (req, res) => {
  try {
    // Express automatically URL decodes params, but let's be explicit
    let { phone } = req.params; // Can be phone, email, or googleId
    phone = decodeURIComponent(phone);
    const { status, limit = 50 } = req.query;

    console.log('[order] Getting orders for identifier:', phone);

    // Find user by phone, email, or googleId
    let user = null;
    let query = {};
    
    // Check if identifier is an email
    if (phone.includes('@')) {
      query = { email: phone.toLowerCase() };
      console.log('[order] Looking up user by email:', phone.toLowerCase());
      user = await User.findOne(query);
    }
    
    // If not found and not an email, try phone
    if (!user && !phone.includes('@')) {
      query = { phone };
      console.log('[order] Looking up user by phone:', phone);
      user = await User.findOne(query);
    }
    
    // If still not found, try googleId (for long numeric strings)
    if (!user && phone.length > 15 && /^\d+$/.test(phone)) {
      query = { googleId: phone };
      console.log('[order] Looking up user by googleId:', phone);
      user = await User.findOne(query);
    }
    
    if (!user) {
      console.error('[order] User not found for identifier:', phone);
      return res.status(404).json({
        success: false,
        message: 'User not found',
      });
    }
    
    console.log('[order] Found user:', user._id, 'role:', user.role);

    // Build query - if user is admin or delivery, show ALL orders
    // Otherwise, show only user's orders
    const orderQuery = {};
    if (user.role === 'customer') {
      orderQuery.customer = user._id; // Only show customer's own orders
      console.log(`[order] Customer user - filtering by customer._id: ${user._id}`);
    } else {
      console.log(`[order] Admin/Delivery user (${user.role}) - showing ALL orders`);
    }
    // If admin or delivery, orderQuery is empty (shows all orders)
    
    if (status) {
      orderQuery.orderStatus = status;
    }

    console.log(`[order] Fetching orders for user: ${user.phone || user.email}, role: ${user.role}, query:`, JSON.stringify(orderQuery));

    const orders = await Order.find(orderQuery)
      .populate('customer', 'firstName lastName phone email')
      .populate('items.menuItem', 'name image')
      .sort({ createdAt: -1 })
      .limit(parseInt(limit));

    console.log(`[order] Found ${orders.length} orders`);

    return res.status(200).json({
      success: true,
      data: orders,
    });
  } catch (error) {
    console.error('[order] error fetching orders:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to fetch orders',
      error: error.message,
    });
  }
};

/**
 * Get single order by ID
 */
exports.getOrder = async (req, res) => {
  try {
    const { phone, orderId } = req.params; // phone can be phone, email, or googleId

    // Find user by phone, email, or googleId
    let user = null;
    let query = {};
    
    // Check if identifier is an email
    if (phone.includes('@')) {
      query = { email: phone.toLowerCase() };
      user = await User.findOne(query);
    }
    
    // If not found and not an email, try phone
    if (!user && !phone.includes('@')) {
      query = { phone };
      user = await User.findOne(query);
    }
    
    // If still not found, try googleId (for long numeric strings)
    if (!user && phone.length > 15 && /^\d+$/.test(phone)) {
      query = { googleId: phone };
      user = await User.findOne(query);
    }
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found',
      });
    }

    // Build order query - customers can only see their own orders, admins/delivery can see any
    const orderQuery = { _id: orderId };
    if (user.role === 'customer') {
      orderQuery.customer = user._id; // Customers can only see their own orders
    }
    // Admin and delivery can see any order (no customer filter)

    const order = await Order.findOne(orderQuery)
      .populate('items.menuItem', 'name image')
      .populate('deliveryAddress');

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found or you do not have permission to view this order',
      });
    }

    return res.status(200).json({
      success: true,
      data: order,
    });
  } catch (error) {
    console.error('[order] error fetching order:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to fetch order',
      error: error.message,
    });
  }
};

/**
 * Update order status (admin/host can update any order, customers can only update their own)
 */
exports.updateOrderStatus = async (req, res) => {
  try {
    const { phone, orderId } = req.params;
    const { status } = req.body;

    if (!status) {
      return res.status(400).json({
        success: false,
        message: 'Status is required',
      });
    }

    const validStatuses = ['pending', 'confirmed', 'preparing', 'ready', 'picked-up', 'delivered', 'cancelled'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: `Invalid status. Must be one of: ${validStatuses.join(', ')}`,
      });
    }

    // Find user by phone, email, or googleId
    let user = null;
    let query = {};
    
    // Check if identifier is an email
    if (phone.includes('@')) {
      query = { email: phone.toLowerCase() };
      user = await User.findOne(query);
    }
    
    // If not found and not an email, try phone
    if (!user && !phone.includes('@')) {
      query = { phone };
      user = await User.findOne(query);
    }
    
    // If still not found, try googleId (for long numeric strings)
    if (!user && phone.length > 15 && /^\d+$/.test(phone)) {
      query = { googleId: phone };
      user = await User.findOne(query);
    }
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found',
      });
    }

    // Build query - admin/delivery can update any order, customers can only update their own
    const orderQuery = { _id: orderId };
    if (user.role === 'customer') {
      orderQuery.customer = user._id; // Customers can only update their own orders
    }
    // Admin and delivery can update any order (no customer filter)

    const order = await Order.findOne(orderQuery);

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found or you do not have permission to update this order',
      });
    }

    order.orderStatus = status;
    if (status === 'delivered') {
      order.actualDeliveryTime = new Date();
    }

    await order.save();

    // Populate customer info for response
    await order.populate('customer', 'firstName lastName phone');

    return res.status(200).json({
      success: true,
      message: 'Order status updated',
      data: order,
    });
  } catch (error) {
    console.error('[order] error updating order status:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to update order status',
      error: error.message,
    });
  }
};

